{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>VO-DML is defined formally in an IVOA Standard, however, this guide is intended to offer practical assistance to those who want to  use VO-DML to create data models, and then create code that can serialize those  models to various formats. </p> <p>The purpose of writing data models is two-fold</p> <ul> <li>It defines concepts for a particular domain in an abstract way that provides a common discourse about meanings within that domain.</li> <li>It provides a machine-readable representation that can be transformed in various ways that allow    instances of the model to be transported, stored and queried.</li> </ul> <p>Start Modelling</p>"},{"location":"Documentation/","title":"Documentation","text":""},{"location":"Documentation/#individual-files","title":"Individual files","text":"<pre><code>gradle vodmlDoc </code></pre> <p>will generate standard documentation into the directory <code>build/generated/docs/vodml/</code> (this can be changed with the <code>outputDocDir</code> setting)</p> <p>This will produce a model diagram, latex and html formatted documentation, as well as a graphml representation of the model that can be hand edited with yEd for nicer looking model diagrams.</p>"},{"location":"Documentation/#site","title":"Site","text":"<pre><code>gradle vodmlSite\n</code></pre> <p>Will generate a whole static site describing the model that is intended to be further processed with mkdocs tool that is configured with the material theme.</p> <p>The site is generated at in the <code>build/generated/docs/vodml-site/</code> directory (which can be  changed with the <code>outputSiteDir</code> setting). If you are creating full documentation site,  then it is likely that you will want to add content other than the autogenerated model  description. In this case the tools have an assumption that the <code>outputSiteDir</code> is set to a <code>generated</code> sub-directory of your configured mkdocs top-level directory.</p> <p>The plugin will create an <code>allnav.yaml</code> file in the project directory which can be added to the mkdocs navigation using <code>yq</code> by adding the following to the <code>build.gradle.kts</code></p> <pre><code>tasks.register&lt;Exec&gt;(\"siteNav\")\n{\ncommandLine(\"yq\", \"-i\",  \"(.nav.[]|select(has(\\\"AutoGenerated Documentation\\\"))|.[\\\"AutoGenerated Documentation\\\"]) += load(\\\"allnav.yml\\\")\", \"mkdocs.yml\")\ndependsOn(\"vodmlSite\")\n}\n</code></pre> <p>which in turn assumes that there is an \"AutoGenerated Documentation\" section in the mkdocs nav that can be added to.</p> <pre><code>nav:\n- Home: index.md\n- AutoGenerated Documentation:\n- Javadoc: generated/javadoc\n</code></pre> <p>The DataModel Template has an example setup.</p>"},{"location":"Installation/","title":"Installation","text":"<p>The VO-DML tooling is based around gradle which itself is based on Java. It is recommended that a minimum of JDK 11 is installed  (to be compatible with other tools) using a package manager for your OS and  similarly use a package manager for gradle installation.</p> <p>The functionality of the tooling is then encapsulated with a gradle plugin which is configured in the quickstart instructions</p> <p>Note the documentation tasks of the tools that produce the overall model diagram also require that graphviz  be installed. </p> <p>If full site generation is required then mkdocs material theme is needed as an external installation dependency along with yq that can be used to automate the mkdocs navigation menu creation.</p>"},{"location":"JavaCodeGeneration/","title":"Java Code Generation","text":"<p>The tooling is capable of generating Java classes that can be used to store instances of the models. The code is annotated to allow JAXB and JPA to operate, which mean that it is easy to  read and write model instances to XML and standard relational databases. It should be noted that the generated code uses java 1.8 constructs.</p> <p>The generated Java code depends on the VO-DML java runtime library, which the plugin will automatically add to the dependencies along with the necessary JAXB and JPA libraries.</p>"},{"location":"JavaCodeGeneration/#generating-the-java-code","title":"Generating The Java code","text":"<p>The command <pre><code>gradle vodmlJavaGenerate\n</code></pre> will generate java code in <code>./build/generated/sources/vodml/java</code> which is on the build classpath and so  <pre><code>gradle build\n</code></pre> will compile and run tests on the generated code. In fact <code>gradle build</code> will  automatically run <code>gradle vodmlJavaGenerate</code> if the code is out of date because the model has been updated.</p>"},{"location":"JavaCodeGeneration/#characteristics-of-the-generated-code","title":"Characteristics of the Generated code","text":"<p>In general the code creates POJOs or data classes - i.e. the classes have very little functionality apart from being stores of the data model. The functionality that they do have is described below.</p>"},{"location":"JavaCodeGeneration/#instance-creation","title":"Instance Creation","text":"<p>To be JPA and JAXB compliant, the classes are Java beans with a no argument constructor, so they can be  default constructed and then getX/setX can be used on the properties.</p> <pre><code>A a = new A();\na.setX(x);\na.setY(y);\n</code></pre> <p>In addition, there are several other ways of creating objects</p>"},{"location":"JavaCodeGeneration/#full-constructor","title":"Full constructor","text":"<p>A constructor with all the possible properties included is</p> <p><pre><code>A a = new A(x,y);\n</code></pre> In addition there is a copy constructor, and for subclasses there is a constructor with arguments that consist of a superclass instance as well as the local members.</p>"},{"location":"JavaCodeGeneration/#fluent","title":"Fluent","text":"<p>Each property has a withX(X x) function</p> <pre><code>A a = new A().withX(x).withY(y);\n</code></pre>"},{"location":"JavaCodeGeneration/#fluent-functional-builder","title":"Fluent functional builder","text":"<p>A static builder that takes a functional argument.</p> <p><pre><code>A a = A.createA( b -&gt; {\nb.x = x;\nb.y = y;\n}\n);\n</code></pre> It should be noted that this style becomes most desirable when there are attributes  which themselves are of a non-primitive type.</p>"},{"location":"JavaCodeGeneration/#serializing-models","title":"Serializing Models","text":"<p>As well as all the individual Enum, ObjectType, and DataType classes, there is an overall ${modelname}Model class generated, that is intended to act as  a 'container' for the individual elements. This is especially useful in the case where the model has references, as then there are some convenience methods for dealing with the automatic setting of reference IDs if necessary.</p>"},{"location":"JavaCodeGeneration/#functions-for-adding-content","title":"Functions for adding content","text":"<p>For each of the concrete objectTypes in the model there is an overloaded <code>addContent()</code> method, which will add the content to the overall instance and find any references.</p> <p>Once all the content has been added, then there is a <code>processReferences()</code> method which will go through the whole model and automatically assign IDs for any references that do not already have them.</p> <p>At this point the overall model object is suitable to be serialized.</p> <p>On reading in a model instance, it is possible to extract any top level ObjectTypes with the <code>public &lt;T&gt; List&lt;T&gt; getContent(Class&lt;T&gt; c)</code> method.</p> <p>Finally, there is a static <code>public static boolean hasReferences()</code> method which can be used to check if the model has any references - if it does not then much of the machinery above (apart from the JAXBContext) is necessary, and individual ObjectTypes may be written.</p> <p>The unit tests for this project show most of the various code features being used</p>"},{"location":"JavaCodeGeneration/#xml-serialization","title":"XML Serialization","text":"<p>A static function to create a suitable JAXBContext is present <pre><code>JAXBContext jc = MyModel.contextFactory();\n</code></pre></p>"},{"location":"JavaCodeGeneration/#json-serialisation","title":"JSON Serialisation","text":"<p>The JSON serialization is implemented with the Jackson library</p> <p>A suitable ObjectMapper is obtained with <pre><code>ObjectMapper mapper = MyModel.jsonMapper();\n</code></pre></p>"},{"location":"JavaCodeGeneration/#reading-and-writing-from-rdbs","title":"Reading and Writing from RDBs","text":"<p>The generated code has JPA annotations to allow storing in RDBs with compliant systems.</p> <p>Operations are not in general cascaded into references - so that the references need to be explicitly managed. In most cases this will be the \"natural\" way to do things  for the model - however at creation time it might be inconvenient to do this so that there is a method <code>persistRefs(javax.persistence.EntityManager _em)</code> that will do a deep persist of any references in the child objects, which in turn then will allow an error free persist of the parent. </p> <p>In general collections are marked for lazy loading, and as a convenience there is a <code>forceLoad()</code> method generated that will do a deep walk of all the collections in a particular type, which will force the loading of the whole instance tree if that is desired.</p> <p>A second convenience method that is created to make it easy to clone an entity is show below <pre><code> MyEntity to_clone = entityManager.find(MyEntity.class, ID);\nto_clone.jpaClone(entityManager);\nentityManager.merge(to_clone);\n</code></pre> which will create a new entity along with any contained compositions, but will maintain the original references.</p> <p>This extra JPA functionality is described by the JPAManipulations interface.</p>"},{"location":"JavaCodeGeneration/#embeddable-datatypes","title":"Embeddable dataTypes","text":"<p>The most natural way to represent dataTypes in JPA is as embeddable, this means that they do not have a separate \"identity\" and are simply represented as columns within the parent entity table. The problem with this is that JPA does not specifically allow inheritance of embeddables (though nor does it disallow the use).  As a consequence the support for inherited embeddables is not uniform in JPA providers.</p> <p>Hibernate seems to support the concept of embeddable hierarchies reasonably well by naturally using the <code>@MappedSuperclass</code> annotation - although there is an irritation in that  the full flexibility of having optional attributes that are dataTypes is not supported as all columns are  made non-nullable - a bug has been submitted https://hibernate.atlassian.net/browse/HHH-14818</p> <p>There are also eclipselink bugs that mean that the suggested way of doing inherited embeddables does not seem to work.</p>"},{"location":"JavaCodeGeneration/#testing-models","title":"Testing models","text":"<p>The java runtime has a number of base classes that aid the testing of model instances - there is an example for the mock coords model. Although it is not obvious from the source code presented because most of the behaviour is inherited from the base test class, this test will actually</p> <ul> <li>round trip the model instance to JSON</li> <li>round trip the model instance to XML</li> <li>validate the model instance</li> </ul> <p>simply by running</p> <pre><code>gradle test\n</code></pre> <p>will generate the actual model code (if not already done) and run the tests as long as</p> <p><pre><code>tasks.test {\nuseJUnitPlatform()\n}\n</code></pre> is set up in the <code>build.gradle.kts</code> file.</p>"},{"location":"JavaCodeGeneration/#general-interfaces","title":"General interfaces","text":"<p>Much of the functionality described above is defined in two interfaces ModelManagement an  instance of which can be obtained with the <code>management()</code> method on the model class and ModelDescription an instance of which can be obtained with the <code>description()</code> method on the model class. These interfaces allow generic model handling code to be written.</p>"},{"location":"PythonCodeGeneration/","title":"Python Code Generation","text":"<p>NB The python code generation should currently be regarded as alpha quality in that it does not serialize model instances to something that is interoperable with the Java generated code. Indeed it is not yet guaranteed to be representing the VO-DML model fully.</p>"},{"location":"PythonCodeGeneration/#using","title":"Using","text":"<p>The command <pre><code>gradle vodmlPythonGenerate\n</code></pre> will generate python data classes in the <code>./build/generated/sources/vodml/python</code> directory by default (changeable with the <code>outputPythonDir</code> vodml setting).</p> <p>The code uses xsdata for XML and JSON serialization and SQLAlchemy for the RDB serialization.</p>"},{"location":"PythonCodeGeneration/#environment","title":"environment","text":"<p>Although the code generation itself does not need python, to run any tests in the project  relies on (https://github.com/xvik/gradle-use-python-plugin) to manage python virtualenv (i.e. https://virtualenv.pypa.io/en/latest/index.html - not all the other ones). This creates the virtualenv in venv directory at top level - it does not seem to do that properly, so it is best to do that manually beforehand...</p> <pre><code>gradle pipInstall\n</code></pre> <p>Depends on python 3.10+</p>"},{"location":"PythonCodeGeneration/#testing","title":"testing","text":"<p>The project is set up with a single python test at the moment that can be run with</p> <pre><code>gradle pytest\n</code></pre>"},{"location":"PythonCodeGeneration/#notes","title":"notes","text":"<ul> <li>difficult to make xsdata and SQlAlchemy work together as they both want to use the same typing style - the generated code is using SQLAlchemy legacy style to allow both libraries to work simultaneously with the same dataclasses.</li> <li>VO-DML dataTypes -&gt; composites?  https://docs.sqlalchemy.org/en/20/orm/composites.html#nesting-composites</li> <li>with Dataclasses kw_only attributes seem the only practical route when there is inheritance, otherwise ordering the kw arguments after the others is painful in the code...</li> </ul>"},{"location":"QuickStart/","title":"Configuring the VO-DML Gradle Plugin","text":"<p>Latest published version </p> <p>In general, a new data model should be started in its own git repository and configured as below (see ProposalDM for a complete example separate from this repository).  If starting a completely new data model then the Template DM Project is probably the easiest way to get going.</p> <p>If adapting an existing data model repository then</p> <ol> <li>Edit a <code>build.gradle.kts</code> file with reference to the plugin (note substitute  below)</li> </ol> <p><pre><code>plugins {\nid(\"net.ivoa.vo-dml.vodmltools\") version \"0.x.x\"\n}\n</code></pre> 2. create a <code>settings.gradle.kts</code> - it is possible just to copy the template version and just edit the <code>rootProject.name</code>.</p> <ol> <li>create the binding file for the model (see below) for more detail </li> </ol> <p>There is nothing else that needs to be done if the VO-DML files in the default place  (see sample build file for some more  hints on how gradle flexibility allows finding of the files to be configured in a variety of ways). </p> <p>If the configuration is successful then</p> <p><pre><code>gradle vodmlValidate\n</code></pre> will attempt to validate the model and print any errors.</p> <ul> <li>vodmlValidate - runs validation on the models. *</li> <li>vodmlJavaGenerate - generate java classes. See generated code guide for details of how to use the generated java code to serialize instances to XML and RDB.  Note that it is also possible to test models using the generated code.</li> </ul>"},{"location":"QuickStart/#detailed-configuration","title":"Detailed configuration","text":"<p>The vodml tools are all configured within a  <pre><code>vodml {\n\n}\n</code></pre> section in the <code>build.gradle.kts</code> file.</p> <ul> <li>vodmlDir - the default is <code>src/main/vo-dml</code> <pre><code>vodmlDir.set(file(\"vo-dml\"))\n</code></pre>   will set the directory to be <code>vo-dml</code></li> <li>vodmlFiles - this is set by default to be all the <code>*.vo-dml.xml</code> files in the vodmlDir, but can be individually overridden.</li> <li> <p>bindingFiles - the files that specify the mapping details between the models and the generated code.</p> </li> <li> <p>outputDocDir - where the generated documentation is created by the <code>gradle vodmlDoc</code> command- default <code>build/generated/docs/vodml/</code>.</p> </li> <li>outputSiteDir - where the mkdocs suitable model description is created by the <code>gradle vodmlSite</code> command - default <code>build/generated/docs/vodml-site</code>.</li> <li>outputJavaDir - where the generated Java is created - the default is <code>build/generated/sources/vodml/java/</code> and it should not    be necessary to ever alter this as gradle will integrate this automatically into the various source paths.</li> <li>catalogFile - in general it is not necessary to set this, as the plugin will create a catalogue file automatically from the vodmlDir and vodmlFiles properties (as well as including files in any dependencies that also contain VO-DML models)   A catalogue file is necessary as the rest of the tooling is designed to use only the filename (no path) for inclusions and references.   If it is desired to create a file manually for a special purpose, then the file should have the format as below - it should be noted that all references to model files will have to be specified if this is done. <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;catalog  xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\"&gt;  &lt;group  prefer=\"system\" &gt;\n&lt;uri\nname=\"IVOA-v1.0.vo-dml.xml\"\nuri=\"src/main/vo-dml/IVOA-v1.0.vo-dml.xml\"/&gt;\n&lt;/group&gt;\n&lt;/catalog&gt;\n</code></pre></li> </ul>"},{"location":"QuickStart/#binding-files","title":"Binding Files","text":"<p>The binding file is used to set up some properties for various functions on the model - the most basic of which is that it provides a connection between the model name and the filename which contains the VO-DML model.</p> <pre><code>&lt;m:mappedModels xmlns:m=\"http://www.ivoa.net/xml/vodml-binding/v0.9.1\"&gt;\n&lt;!-- ========================================\nThis is a minimal sample file for mapping VO-DML models to XSD or Java using the gradle tooling\n --&gt;\n\n&lt;model&gt;\n&lt;name&gt;sample&lt;/name&gt;\n&lt;file&gt;Sample.vo-dml.xml&lt;/file&gt;\n&lt;java-package&gt;org.ivoa.dm.sample&lt;/java-package&gt;\n&lt;xml-targetnamespace prefix=\"simp\" schemaFilename=\"simpleModel.xsd\"&gt;http://ivoa.net/dm/models/vo-dml/xsd/sample/sample&lt;/xml-targetnamespace&gt;\n&lt;/model&gt;\n&lt;/m:mappedModels&gt;\n</code></pre> <p>The schema for the binding file shows what elements are allowed. The binding file for the base IVOA model shows extensive use of the binding features, where it is possible to ignore the automated code generation entirely and substitute hand-written code.</p>"},{"location":"Serialization/","title":"Serialization","text":"<p>The design choices made in the serialization of the models to various formats has been driven by the capabilities of the various libraries/standards that are applicable to the Java generated code. Other language implementations will follow the choices that were made in order to be interoperable.</p> <p>For the serializations (other than the relational database), the general idea is that a \"natural\" serialization for the model has been chosen, in contrast to the approach of MIVOT where the idea is that the model is coerced into a table based model - which of course is similar to the relational  database serialization below. This \"natural\" serialization means that objects are enclosed within their parents to whatever depth  is necessary. The only exception to this is that referenced objects are separated out into their own section early in the  serialization so that they can easily be referenced.</p> <pre><code>classDiagram\n    Model &lt;-- References\n    Model &lt;-- Content</code></pre> <p>The aim of the top level container object is to contain all the referred to objects as well as the general content within a single document. It should be noted that this is a different methodology to the way that the  XML was produced in the previous (ant based) versions of this tooling, and as such the XML target namespaces have been changed.</p>"},{"location":"Serialization/#xml","title":"XML","text":"<p>For the small example model, the overall model object will produce xml like</p> <pre><code>&lt;ser:myModelModel xmlns:ser=\"http://ivoa.net/vodml/sample/serialization\" &gt;\n&lt;refs&gt;\n&lt;refa id=\"id_0\"&gt;\n&lt;val&gt;a value&lt;/val&gt;\n&lt;/refa&gt;\n&lt;refb&gt;\n&lt;name&gt;a name&lt;/name&gt;\n&lt;val&gt;another val&lt;/val&gt;\n&lt;/refb&gt;\n&lt;/refs&gt;\n&lt;SomeContent&gt;\n&lt;zval&gt;a z val&lt;/zval&gt;\n&lt;ref1&gt;id_0&lt;/ref1&gt;\n&lt;ref2&gt;a name&lt;/ref2&gt;\n&lt;/SomeContent&gt;\n&lt;/ser:myModelModel&gt;\n</code></pre>"},{"location":"Serialization/#json","title":"JSON","text":"<p>JSON does not natively have an equivalent to the XML-ID/IDREF mechanism, however, it is possible to distinguish between  a named object as the value of a field or a string or integer literal value for the same field which could be interpreted as a reference to the object if the data model is known.</p> <p><pre><code>{\n\"MyModelModel\" : {\n\"refs\" : {\n\"MyModel:Refa\" : [ {\n\"_id\" : 0,\n\"val\" : \"a value\"\n} ],\n\"MyModel:Refb\" : [ {\n\"name\" : \"a name\",\n\"val\" : \"another val\"\n} ]\n},\n\"content\" : [ {\n\"@type\" : \"MyModel:SomeContent\",\n\"zval\" : \"a z val\",\n\"ref1\" : 0,\n\"ref2\" : \"a name\"\n} ]\n}\n}\n</code></pre> In general where the type of an object cannot be inferred unambiguously from the model,  a member called <code>@type</code> with the UType as value is added.</p>"},{"location":"Serialization/#relational-databases","title":"Relational Databases","text":"<p>The object relational mapping has been done with the capabilities offered by JPA. The general design  decisions that have been made for the mapping are.</p> <ul> <li> <p>The default inheritance strategy is \"JOINED\" - which means that there will be a table per sub-type that has to be joined. This strategy the default as it allows for the widest application of \"NOT NULL\" constraints within the database, at the expense of more complex joins being required. As an alternative a \"SINGLE_TABLE\" strategy can be adopted, by specifying  <pre><code>        &lt;rdb inheritance-strategy=\"single-table\"/&gt;\n</code></pre> in the binding file for the model.</p> </li> <li> <p>DataTypes become embedded as extra columns within the table.</p> </li> </ul> <p>Generating the actual DDL for the database does necessarily depend on some differences between vendors. However, running the test will produce DDL.</p>"},{"location":"Transformers/","title":"Model Transformation","text":"<p>A VO-DML transformation is something that takes the model and expresses it in another way.</p>"},{"location":"Transformers/#documentation","title":"Documentation","text":"<p>The most basic form of transformation is to make human-readable documentation.</p>"},{"location":"Transformers/#code-generation","title":"Code Generation","text":"<p>Here the model is transformed into source code in various languages, which can then be used to hold instances of the data model and then serialize in various formats - currently supported</p> <ul> <li>XML</li> <li>JSON</li> </ul> <p>The languages supported are;</p> <ul> <li>Java</li> <li>Python</li> </ul>"},{"location":"Transformers/#schema","title":"Schema","text":"<p>The models are also transformed into schema that describe the various serializations. The overall aim of the  VO-DML tooling is to be able to exchange instances of the models between different computer languages, with  all the source code and schema automatically generated.</p> <p>The gradle plugin does not currently have a task directly to generate XML and RDB schema from the models, however, this can be done indirectly from the generated Java code as can be seen from the Small java example.</p>"},{"location":"modelling/EclipseVODSL/","title":"Eclipse VODSL Editor","text":"<p>Although it is possible to edit VODSL with any plain text editor as discussed in the introduction, an Eclipse plug-in has been created, that allows VOSDL source to be edited whilst taking advantage of the all the features of the Eclipse that make understanding an navigating the code easier. As well as the expected IDE conveniences of syntax colouring, context sensitive suggestions and ease of navigation, the most important feature of the plug-in are;</p> <ul> <li> <p>Compilation of VODSL to VO-DML.</p> </li> <li> <p>Real-time validation and syntax checking.</p> </li> <li> <p>Navigation via a graphical representation of the model.</p> </li> </ul>"},{"location":"modelling/EclipseVODSL/#vodsl-compilation","title":"VODSL compilation","text":"<p>The plugin will compile any VODSL it finds (files with \u2018.vodsl\u2018 extension) to the output directory specified in the compiler section of the VODSL preferences. The compilation will occur whenever the enclosing project is built, and if \u201cbuild automatically\u201d is set then this will be every time that the VODSL file is saved.</p>"},{"location":"modelling/EclipseVODSL/#the-graphical-view","title":"The Graphical View","text":"<p>The graphical view of the model is implemented in FXDiagram and uses some of the same conventions as the standard graphical representation produced by the VO-DML tools, i.e.\u00a0</p> <ul> <li> <p>subclass relations are represented by red connectors</p> </li> <li> <p>reference relations are represented by green connectors</p> </li> <li> <p>composition relations are represented by blue connectors</p> </li> </ul> <p>The graphical view is opened by right clicking on one of the declarations in the text view of the model and selecting \u201cShow in FXDiagram $\\Rightarrow$ VODSL model\u201d</p> <p></p> <p>The graphical representation of the model is basically read-only in that it is not possible to edit model features in the graphical window. However, as well as visualisation, it can usefully be used for navigation around the model.</p> <p>Navigation in the view is possibly a little un-intuitive - on a Mac the following gestures work</p> <ul> <li> <p>Panning is done with a two finger drag on trackpad.</p> </li> <li> <p>Zooming is done with a two finger pinch gesture.</p> </li> <li> <p>A menu consisting of a ring of icons can be invoked with a two finger   tap - the menu as a range of functions including changing the zoom and   saving the diagram.</p> </li> <li> <p>Double-clicking on a model item in the view will select that item in   the textual view, and conversely, right-clicking in the textual view   and chosing \"Show in FXDiagram\" again will select the item in the   graphical view.</p> </li> </ul>"},{"location":"modelling/EclipseVODSL/#installing-the-eclipse-plugin","title":"Installing the Eclipse plugin","text":"<p>It is generally recommended to install the plugin in its own instance of Eclipse (due to some dependencies that are difficult to find) rather than using the usual eclipse plugin installation mechanisms in a pre-existing eclipse instance. This can be achieved thus;</p> <ol> <li> <p>Ensure that you have a Java 11 or later installed on your machine as     well as graphviz</p> </li> <li> <p>download the eclipse installer https://www.eclipse.org/downloads/</p> </li> <li> <p>Run the eclipse installer and select \"advanced mode\" from the menu     at top right.</p> </li> <li> <p>use the green arrow at the top right to add a new user product with     the following     https://raw.githubusercontent.com/pahjbo/vodsl/master/VODSLEditor.setup</p> </li> <li> <p>select the \"VODSL\" user product and just click next through the     dialogs until you have a running editor.</p> </li> <li> <p>create a new \"general\" project and then create a file with extension     <code>.vodsl</code> - eclipse will prompt whether to convert the project to     \"XText\" - say yes.</p> </li> </ol> <p>The image below shows the above steps being executed.</p> <p></p>"},{"location":"modelling/EclipseVODSL/#development-of-the-vodsl-editor","title":"Development of the VODSL Editor.","text":"<p>The tools associated with the VODSL language are being developed in a GitHub repository https://github.com/pahjbo/vodsl and use XText to implement the language itself as well as the Eclipse integration.</p> <p>[^1]: The eclipse plugin has a small bug in that it will sometimes make the first separation of a name reference with a colon even when the referred to type is in fact in the same model</p>"},{"location":"modelling/UML/","title":"UML","text":""},{"location":"modelling/UML/#configuring-the-uml-tool","title":"Configuring the UML tool","text":"<p>In general it is necessary to configure a UML tool with the IVOA \"profile\" to restrict the metamodel to that used by VO-DML.</p> <p>TBC</p>"},{"location":"modelling/UML/#xmi-support-in-the-gradle-tooling","title":"XMI support in the gradle tooling","text":"<p>As there are several UML tools and the XMI produced by each is slightly different, there is not a specific XMI to VO-DML task, but rather a base <code>net.ivoa.vodml.gradle.plugin.XmiTask</code> that can be customized with the correct XSLT in the <code>build.gradle.kts</code></p> <p><pre><code>tasks.register(\"UmlToVodml\", net.ivoa.vodml.gradle.plugin.XmiTask::class.java) {\nxmiScript.set(\"xmi2vo-dml_MD_CE_12.1.xsl\") // the conversion script - automatically found in the xslt directory\nxmiFile.set(file(\"models/ivoa/vo-dml/IVOA-v1.0_MD12.1.xml\")) //the UML XMI to convert\nvodmlFile.set(file(\"test.vo-dml.xml\")) // the output VO-DML file.\ndescription = \"convert UML to VO-DML\"\n}\n</code></pre> The available conversion scripts are those in the xslt directory with <code>xmi2vo-dml</code> as part of their name.</p>"},{"location":"modelling/VODSL/","title":"VODSL","text":""},{"location":"modelling/VODSL/#vodsl-support-in-the-gradle-tools","title":"VODSL support in the gradle tools","text":"<p>There is a <code>vodslToVodml</code> task that will convert models authored in vodsl into standard VO-DML.</p> <p>the configurable properties within the vodml extension are;</p> <ul> <li>vodslDir - the default is <code>src/main/vodsl</code></li> <li>vodslFiles - this is set by default to be all the <code>*.vodsl</code> files in the vodslDir, but can be individually set.</li> </ul> <p>the task will write the VO-DML files into the <code>vodmlDir</code></p> <p>Any dependencies that have VO-DML models within them will have their VO-DML automatically converted to VODSL and placed in the <code>build/tmp</code> directory. Any target VODSL files will have to explicitly include the dependencies with a relative path into that directory.</p> <p>If you want to have the VO-DML generated automatically from the VODSL rather than running this task manually, then</p> <p><pre><code>tasks.named(\"vodmlJavaGenerate\") {\ndependsOn(\"vodslToVodml\")\n}\n</code></pre> in the <code>build.gradle.kts</code> file would run the task before the Java generation for instance.</p>"},{"location":"modelling/VODSL/#creating-vodsl-from-existing-vo-dml","title":"Creating VODSL from existing VO-DML","text":"<p>If it is desired to create VODSL from some existing VO-DML then there is a special task that can be run from the commandline with arguments (i.e. does not have to be configured in the <code>build.gradle</code> file as it would not be a repeated part of the workflow) The task has the <code>--dml</code> parameter to indicate the input VO-DML file and the <code>--dsl</code> parameter to indicate the output VODSL file.</p> <pre><code>gradle vodmlToVodsl --dml=models/sample/sample/vo-dml/Sample.vo-dml.xml --dsl=test.vodsl </code></pre>"},{"location":"modelling/VODSL/#vodsl-language","title":"VODSL language","text":"<p>The VODSL language use the same underlying meta-model as VO-DML but uses a mapping to a syntax that makes it easier for humans to write by hand. It uses a general C/Java-like syntax with the following characteristics;</p> <ul> <li> <p>pairs of curly braces representing grouping</p> </li> <li> <p>attribute declarations ending with semi-colons <code>;</code></p> </li> <li> <p>line comments introduced by <code>// comment</code></p> </li> <li> <p>block comments <code>/* comment */</code></p> </li> <li> <p>keywords</p> <pre><code>model,author,include,package,abstract,primitive,dtype,\notype,as,ordered,composition,enum,references,semantic,\nsubset,iskey,ofRank\n</code></pre> </li> <li> <p>attibute names precede their types</p> </li> <li> <p><code>\"documentation strings\"</code> are enforced for all types</p> </li> <li> <p>multiplicities are introduced by <code>@</code></p> </li> </ul> <p>The syntax of various parts of the language are described in the following sections. For a fuller description of the semantics of the language, the VO-DML standard itself should be consulted.</p>"},{"location":"modelling/VODSL/#model-declaration","title":"Model Declaration","text":"<p>The model declaration includes the name of the model its version followed by a description and then a number of authors.</p> <pre><code>model example (0.1) \"description here\" \n   author \"Paul Harrison\"\n   author \"An Other\"\n\n   include \"IVOA-v1.0.vodsl\"\n</code></pre> <p>It will almost always be the case that there should be an include statement that includes the standard IVOA VO-DML base model which defines a number of fundamental primitive types. There can be additonal includes to re-use parts of other models.</p>"},{"location":"modelling/VODSL/#packages","title":"Packages","text":"<p>Packages may be used to partition the namespace in a model. Is is not required that all definitions live in a package as there is an assumed \u201cunnamed\u201d which exists at the top-level of the model. Packages may be nested.</p> <pre><code>package p \"package\" {\n    package n \"nested package\" {\n\n    }\n}\n</code></pre> <p>Note that the above fragment is not actually legal without the inner package containing a type definition.</p>"},{"location":"modelling/VODSL/#types","title":"Types","text":"<p>Types are defined by starting with the particular type keyword. Where appropriate this might be preceded by <code>abstract</code> and if the type is a sub-type of another type then after the type name the supertype is indicated with <code>-&gt;</code>.</p> <pre><code>abstract otype ad1 -&gt; base \"an abstract subtype \"{  \n}\n</code></pre>"},{"location":"modelling/VODSL/#primitives","title":"Primitives","text":"<pre><code>primitive angle \"another primitive\"\n</code></pre> <p>note the lack of a semi-colon at the end of this declaration.</p>"},{"location":"modelling/VODSL/#enumerations","title":"Enumerations","text":"<pre><code>enum options \"an enum\" {\n    val1 \"first option\",\n    val2 \"second option\"\n}   \n</code></pre>"},{"location":"modelling/VODSL/#datatypes","title":"DataTypes","text":"<p>DataTypes are defined with the \u201cdtype\u201d keyword. This definition also introduces the syntax for attribute definitions, which are defined between the curly braces of the main DataType definition.</p> <pre><code>dtype myQuant -&gt; ivoa:RealQuantity \"a flagged quantity\" {\n            flag : ivoa:boolean \"the flag\" ;\n}\n</code></pre>"},{"location":"modelling/VODSL/#objecttypes","title":"ObjectTypes","text":"<p>ObjectTypes are defined with the \u201cotype\u201d keyword.</p> <pre><code>otype o1 {\n         /* the following attribute is a 'natural key' for the otype */\n           name : ivoa:string iskey \"the identifier\";\n               bv : ivoa:anyURI  \"Description\";\n            /* note use of ^ to be able to \n                    re-use reserved word.*/ \n            ^author: ivoa:string \"author\"; \n}\n</code></pre> <p>This definition also introduces the <code>iskey</code> attribute modifier to hint to any code generation systems that this attribute should be regarded as a \u201cnatural key\u201d for the ObjectType and used rather than generating a surrogate key.</p>"},{"location":"modelling/VODSL/#multiplicities","title":"Multiplicities","text":"<pre><code>otype multiplicities \"the @ sign introduces a multiplicity\"\n{\n    m1 : ivoa:integer @? \"0 or 1\";\n    m2 : ivoa:integer @* \"0 or many\";\n    m3 : ivoa:integer @+ \"1 or many\";\n    m4 : ivoa:integer @[2] \"twice (as an array?)\";\n}\n</code></pre>"},{"location":"modelling/VODSL/#references-and-compositions","title":"References and Compositions","text":"<p>This example shows the syntax for references and compositions and the difference in their semantics.</p> <pre><code> /*  this referred to otype is not affected by the lifecycle\n   of other instances in the model */\n otype ReferedTo { \n    test1: ivoa:integer \"\";\n }\n\n/* instances of this contained class will only live\n   as long as the containing instance.  */\notype Contained  {\n    test2: ivoa:string \"\";\n }\n\notype RCTest { \n    ref references ReferedTo \"\";\n    contained : Contained @+ as composition \"\";\n}\n</code></pre>"},{"location":"modelling/VODSL/#subsetting","title":"Subsetting","text":"<p>Subsetting is an advanced VO-DML feature, where an attribute of a subtype can be declared to be a particular sub-type of the supertype\u2019s attribute type.</p> <pre><code>otype subs -&gt; base {\n    /* note that the requirement to refer to the q attribute of base */\n   subset base.q as myQuant; //the type of base.q is a supertype of myQuant\n}\n</code></pre>"},{"location":"modelling/VODSL/#scoping","title":"Scoping","text":"<p>Type names need to be brought into scope by including the model where they are defined, and thereafter they can be referred to by prefixing the type name with the model name followed by a colon. Types defined in the same model as where they are referred to do not need this model prefix.</p> <p>If the type is futher namepspaced by packages, then to refer to a type in a package the enclosing package names should be separated by periods. The use of a period to separate name parts is also necessary when referring to an attribute of a type - e.g.\u00a0when subsetting.[^2]</p>"},{"location":"modelling/VODSL/#full-example-of-vo-dsl","title":"Full example of VO-DSL","text":"<p>The following is the full model from which the sections above took snippets.</p> <pre><code>/*\n *  created on 25 Feb 2022 \n */\n\n model example (0.1) \"description here\" \n   author \"Paul Harrison\"\n   author \"An Other\"\n\n   include \"IVOA-v1.0.vodsl\"\n\npackage p \"top level package\" {\n    package n \"nested package\" {\n     primitive angle \"another primitive\"     \n    }\n}\n\nenum options \"an enum\" {\n    val1 \"first option\",\n    val2 \"second option\"\n}   \n\ndtype aQuant -&gt; ivoa:Quantity \"an angle quantity\" {\n            value : p.n.angle  \"angle\";\n}\n\nabstract otype base {\n            q : ivoa:Quantity \"a quantity\";   \n}\n\nabstract otype ad1 -&gt; base \"an abstract subtype \"{  \n}\n\notype o1 {\n         /* the following attribute is a 'natural key' for the otype */\n           name : ivoa:string iskey \"the identifier\";\n               bv : ivoa:anyURI  \"Description\";\n            /* note use of ^ to be able to \n                    re-use reserved word.*/ \n            ^author: ivoa:string \"author\"; \n}\n\ndtype myQuant -&gt; ivoa:RealQuantity \"a flagged quantity\" {\n            flag : ivoa:boolean \"the flag\" ;\n}\n\n/* it should be noted in this example that\n * @* and @+ are not \"recommended\" for attributes - it \n   might be better to use composition of otypes - but this is \n   not always the case */\notype multiplicities \"the @ sign introduces a multiplicity\"\n{\n    m1 : ivoa:integer @? \"0 or 1\";\n    m2 : ivoa:integer @* \"0 or many\";\n    m3 : ivoa:integer @+ \"1 or many\";\n    m4 : ivoa:integer @[2] \"twice (as an array?)\";\n}\n\n /*  this referred to otype is not affected by the lifecycle\n   of other instances in the model */\n otype ReferedTo { \n    test1: ivoa:integer \"\";\n }\n\n/* instances of this contained class will only live\n   as long as the containing instance.  */\notype Contained  {\n    test2: ivoa:string \"\";\n }\n\n/* this example references and contains the above types */\notype RCTest { \n    ref references ReferedTo \"\";\n    contained : Contained @+ as composition \"\";\n}\n\n/* an example of subsetting */\notype subs -&gt; base {\n    /* note that the requirement to refer to the q attribute of base */\n   subset base.q as myQuant; //the type of base.q is a supertype of myQuant\n}\n\n/* an example of the syntax for a constraint */\notype constrained {\n            val : ivoa:integer \"just using a natural language constraint\" \n              &lt; \"greater than 5\" as Natural&gt; ;\n        }\n</code></pre>"},{"location":"modelling/VODSL/#rationale-for-vodsl","title":"Rationale for VODSL","text":"<p>VO-DML is the IVOA standard language for creating data models and the standard document details the reasons behind its creation and the advantages of using such a language over other more general languages such as UML. The standard representation of VO-DML is XML and as such it is difficult to edit model instances directly, especially as the XML is a direct representation of the VO-DML meta model. The most common practice envisaged by the standard is that data models are generally created by visual UML tools and then the UML converted to VO-DML via the XMI interchange format. This approach does work, but it has several disadvantages.</p> <ol> <li> <p>UML tools tend to have poor interoperability despite the standard     XMI interchange format</p> <ul> <li> <p>There needs to be a specialized XMI $\\Rightarrow$ VO-DML   conversion written for each UML tool (and sometimes for each   version of a particular tool).</p> </li> <li> <p>It is difficult to \u201cimport\u201d an existing VO-DML definition into a   particular UML tool.</p> </li> </ul> </li> <li> <p>Because of this poor interoperability between UML tools it is     difficult for authors to collaborate on the creation of a data model</p> <ul> <li> <p>even if they are using the same tool and use XMI in a version   control system, there is</p> </li> <li> <p>if they are using different UML tools, comprehending what might be   small incremental changes in the source becomes impossible.</p> </li> </ul> </li> <li> <p>Commercial UML tools tend to be expensive, and the free ones less     feature rich.</p> </li> </ol> <p>These difficulties were the inspiration for creating VODSL as a new route to producing VO-DML with the following characteristics;</p> <ul> <li> <p>Text based for easy management by version control systems.</p> </li> <li> <p>Concise, so that it is easy for direct comprehension by humans.</p> </li> </ul> <p>The VODSL language and its associated tools are version controlled in GitHub as well as some examples of models expressed in VODSL.</p>"},{"location":"modelling/VODSL/#relationship-to-vo-dml","title":"Relationship to VO-DML","text":"<p>The diagram in the introduction shows the role that VODSL plays in the VO-DML creation ecosystem - The yellow arrows indicate transformations that can be made programmatically between the different formats, and the green arrows indicate ways in which the source can be edited and the tools that can be used to create or edit that particular representation. It shows that VODSL has a similar role to XMI/UML in the creation of VO-DML, although with one significant advantage in that there is an exact transformation VO-DML$\\Rightarrow$VODSL.</p> VODSL UML Easier to perform global refactoring vs Easier to visualise the whole model Instant validation[^1] vs Full validation only after XSLT transformation of XMI Easier to merge contributions from two authors textually vs Rely on UML tool to have model merging facility <p>[^1]: when using the Eclipse plug-in</p>"},{"location":"modelling/designIntro/","title":"Designing Models","text":""},{"location":"modelling/designIntro/#testing-serialization","title":"Testing serialization.","text":""},{"location":"modelling/modellingIntro/","title":"Writing VO-DML Models","text":""},{"location":"modelling/modellingIntro/#authoring-ecosystem","title":"Authoring Ecosystem","text":"<p>Although VO-DML/XML is the standard serialization of VO-DML models, and it is possible to create VO-DML directly by editing in a text editor (and the model schema might be helpful in guiding this editing), it is generally easier to model using either</p> <ul> <li>VODSL</li> <li>UML</li> </ul>"}]}